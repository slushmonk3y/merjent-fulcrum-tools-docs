<!-- start:source.tmpl.hbs -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
		<title>Mtools/ReportHelpers.js</title>
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<link href="https://fonts.googleapis.com/css?family=PT+Mono" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="css/prism.min.css">
		<link type="text/css" rel="stylesheet" href="css/template.min.css">
		<script type="text/javascript">
			window.TEMPLATE_OPTIONS = {"includeDate":true,"dateFormat":"Do MMM YYYY","systemName":"Merjent Fulcrum Tools","systemSummary":"Modules for modifying Fulcrum apps","systemLogo":"","systemColor":"","navMembers":[{"kind":"module","title":"Modules","summary":"All documented modules."},{"kind":"class","title":"Classes","summary":"All documented classes."},{"kind":"external","title":"Externals","summary":"All documented external members."},{"kind":"global","title":"Globals","summary":"All documented globals."},{"kind":"mixin","title":"Mixins","summary":"All documented mixins."},{"kind":"interface","title":"Interfaces","summary":"All documented interfaces."},{"kind":"namespace","title":"Namespaces","summary":"All documented namespaces."},{"kind":"tutorial","title":"Tutorials","summary":"All available tutorials."}],"footer":"","copyright":" ","linenums":true,"collapseSymbols":true,"inverseNav":true,"inlineNav":false,"outputSourceFiles":false,"sourceRootPath":null,"disablePackagePath":true,"outputSourcePath":false,"showTableOfContents":true,"showAccessFilter":true,"analytics":null,"methodHeadingReturns":true,"sort":"longname","search":true,"favicon":null,"stylesheets":[],"scripts":[],"monospaceLinks":false,"cleverLinks":false,"default":{"outputSourceFiles":false}};
			window.DOCLET_TOC_ENABLED = false;
			window.DOCLET_AFILTER_ENABLED = false;
		</script>
</head>
<body>
	<!-- start:navbar.hbs -->
	<header class="navbar navbar-default navbar-fixed-top navbar-inverse">
		<div class="container">
			<div class="navbar-header">
				<a class="navbar-brand" href="index.html">
					Merjent Fulcrum Tools
				</a>
				<!-- displayed on small devices -->
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="topNavigation">
				<ul class="nav navbar-nav">
								<li class="dropdown">
									<a href="list_class.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="DataEventHelpers.html">DataEventHelpers</a></li>
											<li><a href="FieldHelpers.html">FieldHelpers</a></li>
											<li><a href="FulcrumHelpers.html">FulcrumHelpers</a></li>
											<li><a href="Helpers.html">Helpers</a></li>
											<li><a href="MerjentApp.html">MerjentApp</a></li>
											<li><a href="ReportHelpers.html">ReportHelpers</a></li>
											<li><a href="RequestHelpers.html">RequestHelpers</a></li>
									</ul>
								</li>
								<li class="dropdown">
									<a href="list_module.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="module-dataEventMtools.html">dataEventMtools</a></li>
											<li><a href="module-merjentAppModule.html">merjentAppModule</a></li>
											<li><a href="module-reportMtools.html">reportMtools</a></li>
									</ul>
								</li>
								<li class="dropdown">
									<a href="list_namespace.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="MerjentApp.AppTemplates.html">MerjentApp.AppTemplates</a></li>
											<li><a href="MerjentApp.DefaultMethods.html">MerjentApp.DefaultMethods</a></li>
											<li><a href="MerjentApp.PermissionMethods.html">MerjentApp.PermissionMethods</a></li>
											<li><a href="MerjentApp.StatusMethods.html">MerjentApp.StatusMethods</a></li>
									</ul>
								</li>
								<li class="dropdown">
									<a href="list_tutorial.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="MerjentApp.html">MerjentApp</a></li>
											<li><a href="tutorial-Utils.html">Utils</a></li>
									</ul>
								</li>
				</ul>
					<!-- start:lunr-search-navbar.hbs -->
					<form class="navbar-form navbar-right" role="search">
						<div class="input-group">
							<input type="text" class="form-control" placeholder="Search" id="lunr-search-input">
							<div class="input-group-btn">
								<button class="btn btn-default" id="lunr-search-submit">
									<i class="glyphicon glyphicon-search"></i>
								</button>
							</div>
						</div>
					</form>
					<!-- start:lunr-search-navbar.hbs -->		</div>
		</div>
	</header>
	<!-- end:navbar.hbs -->		<div class="page-header">
			<div class="container">
				<span class="kind">source</span>
				<h1><span class="name">Mtools/ReportHelpers.js</span></h1>
			</div>
		</div>
	<div class="container content">
		<div class="row">
			<div class="col-md-12 main-content">
		<section class="source-section">
			<article></article>
			<pre class="prettyprint source language-javascript line-numbers"><code class="language-javascript">import { Helpers,FulcrumHelpers,MLoadRecs,FieldHelpers,MfldColl,Mfld,SecOpt } from "./FieldHelpers";

// import { MfldColl } from "./FieldHelpers";
//#region ******************************** REPORT HELPERS ************************************/

/**
 * @description Description placeholder
 */
class ReportHelpers extends FieldHelpers{
   constructor() {super()}
   /**
    * @description Gets description text from field
    *
    * @param {string} [dn=''] 
    * @returns {string} 
    */
   getDesc(dn = '') {
      return FIELD(dn).description ? ' (&lt;i>' + FIELD(dn).description + ')&lt;/i>' : '';
   };
   
   /**
    * @description Get choicelist options from a refrenced fulcrum choicelist app if choices not located in app
    *
    * @param {string} [id=''] 
    * @returns {string[]}
    */
   getChoices(id = '') {
      var options = { "url": "https://api.fulcrumapp.com/api/v2/choice_lists/" + id + ".json" };
      var list = API('/choice_lists', options).choice_list;
      var choices = list.choices;
      return choices;
   };

   /**
    * @description Creates html content for a single cell of grid using Merjent .grid-lo stylesheet. Without nesting within a surrounding div. 
    * The label and value will be displayed horizontally instead of vertically.
    *
    * @param {(string|Mfld)} input - data name or Mfld
    * @param {*} [i=null] 
    * @returns {string} 
    */
   getSimpleCell(input, i = null) {
      var output = '';
      var mfld = Object.prototype.toString.call(input) === '[object Object]' ? input : mkMfld(input);
      output = `&lt;div>${ mfld.label}&lt;/div>&lt;div>${this.fldVal(mfld, i)}&lt;/div>`;
      return output;
   };

   //! Set type property to 'mLabel' to print Label on pdf Label Field data name in order to print Label
   /**
    * @description Creates html rows with the getSimpleCell() method. (ie: horizontal label/value)
    * 
    * If field is a label, the type property must be set to 'mLabel' in order to print on pdf.
    * @param {Mfld} [mflds=[]] 
    * @param {*} [i=null] 
    * @returns {string} 
    */
   getSimpleRows(mflds = [], i = null) {
      const excludeTypes = ["Label", "Section", "PhotoField", "VideoField", "AudioField", "BarcodeField", "Repeatable", "SignatureField", "HyperlinkField", "RecordLinkField"];
      let output = '';
  
      for (const mfld of mflds) {
          const fldType = mfld.type || FIELDTYPE(mfld.data_name);
  
          if (mfld.type === 'mLabel') {
              output += `&lt;div>${mfld.label}&lt;/div>&lt;div>${mfld.val}&lt;/div>`;
          } else if (!excludeTypes.includes(fldType)) {
              output += this.getSimpleCell(mfld, i);
          }
      };
  
      return output;
  }


   /**
    * @description create a single cell using Merjent .grid-lo stylesheet.
    * 
    * Span width is read from Mfld input
    *
    * @param {(string|Mfld)} input 
    * @param {*} [i=null] - i is only used if called within a repeatable loop
    * @returns {string} 
    */
   getFormCell(input, i = null) {
      // Convert input to Mfld object if it's not already
      const mfld = Object.prototype.toString.call(input) === '[object Object]' ? input : mkMfld(input);
      const span = mfld.span || 1;
      const lbl = mfld.label;
      const val = this.fldVal(mfld, i);

      // Create the output HTML
      return `\
         &lt;div style="grid-column: span ${span}; white-space: pre-line;">\
            &lt;div>${lbl}&lt;/div>\
            &lt;div>${val}&lt;/div>\
         &lt;/div>`;
   };

   
   /**
    * @description Populate rows of grid using Merjent .grid-lo .default stylesheet.
    *
    * @param {Mfld} [mflds=[]] 
    * @param {*} [i=null]  - Only used mflds are from a Repeatable section
    * @param {string[]} [exc=[]] - Array of data names to exclude from the grid
    * @returns {string} 
    */
   getFormRows(mflds = [], i = null, exc=[]) {
      const excludeTypes = ["Label", "Section", "PhotoField", "VideoField", "AudioField", "BarcodeField", "Repeatable", "SignatureField", "HyperlinkField", "RecordLinkField"];
      let output = '';
  
      for (const mfld of mflds) {
         const opt = mfld &amp;&amp; mfld.opt ? mfld.opt : null;
         const blank = this.optionIs(opt,'na') ? 'N/A' : '---'
         const val = this.fldVal(mfld, i);
         const hideNull = this.optionIs(opt,'hn') &amp;&amp; val == blank ? true : null
         if(!exc.includes(mfld.data_name) || this.optionIs(opt,'hn')){
            const fldType = mfld.type || FIELDTYPE(mfld.data_name);
            if (mfld.type === 'mLabel') {
               const span = mfld.span || 4;
               output += `\
                     &lt;div style="font-style: italic; grid-column: span ${span}; white-space: pre-line;">\
                        &lt;div>${mfld.label}&lt;/div>\
                        &lt;div>${val}&lt;/div>\
                     &lt;/div>`;
            } else if (!excludeTypes.includes(fldType) &amp;&amp; !hideNull) {
               output += this.getFormCell(mfld, i);
            }
         }
      };
  
      return output;
   }

   /**
    * @description Gets the central text to display in a section header from a SecText object.
    * 
    * If there is a 'center' property it will be the value.
    * If there is a 'rep_data_name' property it will be the value.
    * Defaults to the LABEL(data_name)
    *
    * @param {SecOpt} secOpt 
    * @param {*} index 
    * @returns {string} 
    */
   getSecCenter(secOpt, index) {
      return secOpt.center ? secOpt.center
         : secOpt.rep_data_name ? this.formatVal(REPEATABLEVALUES(VALUE(secOpt.rep_data_name), secOpt.data_name)[index])
            : secOpt.data_name ? LABEL(secOpt.data_name)
               : '';
   }

    /**
    * @description builds a SecOpt object based off an old style object
    *
    * @param {} obj - The object to convert to SecOpt
    * @returns {SecOpt} 
    */
   obj2SecOpt(obj) {
      var secOpt = new SecOpt();
      for (const key in obj) {
         if (Object.prototype.hasOwnProperty.call(secOpt, key)) {
         secOpt[key] = obj[key];
         }
      }
      return secOpt;
   }

   /**
    * @description Constructs string for section header text
    *
    * @param {} secOpt - Either a SecOpt object or an old style object to be converted to SecOpt
    * @param {number} [index=0] 
    * @returns {string} 
    */
   getSecTxt(secOpt, i = null) {
      if(secOpt.hide == true){return ''}
      const isSecOpt = this.isInstance(secOpt, SecOpt)
      if(!isSecOpt) {secOpt = this.obj2SecOpt(secOpt)}
      secOpt.index = !secOpt.index ? secOpt.index = i : secOpt.index;
      return secOpt.text()
  }

   /**
    * @description Constructs html for section header from secOpt object. 
    * For a non-repeatable use EITHER:
    *  the 'data_name" property, to label after a section data name OR
    * the 'center' property to manually enter a string for the section label.
    *
    * @param {SecOpt}secOpt
    * @param {number} i - only for repeatables
    * @returns {string} - html string.
    * @example
    * //To label this section of the report after a section in the app use the data name of the section
    * {"data_name": "inspection_details"}
    * 
    * @example
    * //To hardcode the section label to a text string use 'center' property instead
    * {"center": "Inspection Details"}
    * 
    * 
    * @example
    * //Use 'prefix' and 'suffix' to hardcode additional text
    * {"prefix":"Appendix: ", "center":"A - ", "suffix":"Observed Species"} //result = Appendix A - Observed Species
    * {"prefix":VALUE('location') + ' - ', "data_name":"inspection_details"} //result = PL1 - Inspection Details
    * 
    * @example
    * //Repeatable Examples    * 
    * {"rep_data_name":"followup_reporting", "data_name": "date_identified"} //Section result = Follow-up Reporting, Subsection result = ${date_identified}
    * {"rep_data_name":"follow-up reporting", "data_name": "date_identified", "suffix":" - ", "lblIndex":true} //Section result = Follow-up Reporting, Subsection result = ${date_identified} - ${i}
    */
   getSecHtml(secOpt = {}, i=null){
      if(!secOpt || secOpt.hide == true){return ''}
      const isSecOpt = this.isInstance(secOpt, SecOpt)
      if(!isSecOpt) {secOpt = this.obj2SecOpt(secOpt)}
      secOpt.index = !secOpt.index ? secOpt.index = i : secOpt.index;
      return secOpt.html();
   }

   /**
    * @description Builds yesNo section using Merjent .yn-col stylesheet. Input either Section data name or MfldColl.
    *
    * @param {string} [dn=''] 
    * @param {MfldColl} [mflds=[]] 
    * @param {{}} [secOpt={}] 
    * @returns {string} 
    */
   buildYNSection(dn='',mflds=[], secOpt = {}) {
      mflds = mflds.length ? mflds : this.mkMflds(FIELDNAMES(dn));
      const divder = this.getSecHtml(secOpt);
      const htmlRows = this.getSimpleRows(mflds);
      const output = `\
         &lt;div class="clump">\
            ${divder}\
            &lt;div class="grid-lo yn-col">\
               &lt;div class="rows">\
                  ${htmlRows}\
               &lt;/div>\
            &lt;/div>\
         &lt;/div>`;
      return output;
   }

   /**
    * @summary Build an entire grid section using Merjent .grid-lo .default stylesheet. 
    * @description Input section data name or MfldColl.
    * 
    * buildDefaultSection > [mkMflds] > getSecHtml > getFormRows
    * @param {string} dn - The data name of the section. If not provided, it will be determined from the field names.
    * @param {MfldColl} mflds - An array of field objects to be included in the section. If not provided, it will be determined from the field names.
    * @param {Object} secOpt - An optional object containing section options such as prefix, suffix, and other display settings.
    * @returns {string} - The HTML string representing the section. 
    */
   buildDefaultSection(dn = '', mflds = [], secOpt = {}) {
      mflds = mflds.length ? mflds : this.mkMflds(FIELDNAMES(dn));
      const divider = this.getSecHtml(secOpt);
      const htmlRows = this.getFormRows(mflds);
      const output = `\
         &lt;div class="clump">
            ${divider}\
            &lt;div class="grid-lo default">\
               &lt;div class="rows">\
                  ${htmlRows}\
               &lt;/div>\
            &lt;/div>\
         &lt;/div>`;
      return output;
   }

   /**
    * @summary Build an entire grid section using Merjent .grid-lo .default stylesheet.
    * @description Input a repeatable section data name
    * 
    * buildRepeatableSubsec > [mkMflds] > getSecHtml > getFormRows
    * @param {string} repDn='' - The data name of the repeatable section.
    * @param {MfldColl} mflds=[] - mflds to include in the section.
    * @param {{}} [secOpt={}] 
    * @param {string[]} [exc=[]] - Array of data names to exclude from the grid
    * @returns {string} 
    */
   buildRepeatableSubsec(repDn = '', mflds = [], secOpt = {},exc=[],css='') {
      const vals = VALUE(repDn) || null;
      if (!vals || vals.length &lt; 1) return '';

      let out = '';
      for (var i = 0; i &lt; vals.length; i++) {
         secOpt.index = i;
         const divider = this.getSecHtml(secOpt);
         const htmlRows = this.getFormRows(mflds,i,exc);
         out += `\
            &lt;div class="clump ${css}">\
               ${divider}\
               &lt;div class="grid-lo default">\
                  &lt;div class="rows">\
                     ${htmlRows}\
                  &lt;/div>\
               &lt;/div>\
            &lt;/div>`;                 
      }
      return out;
   };

   /**
    * @description Request to pull only photos with a caption beginning with '#'
    *
    * Use this to create photoOarr for input into buildPhotoSec() method.
    * @param {{}} [recIDs=['']] 
    * @param {string} [appID=''] 
    * @param {string} [photoDn='photos'] 
    * @returns {*} 
    */
   getTaggedPhotos(recIDs = [''], appID = '', photoDn = 'photos') {
      var result = QUERY(`SELECT _record_id, _status, unnest(${photoDn}) as photo_id, unnest(${photoDn}_captions) as caption 
         FROM "${appID}" 
         WHERE _record_id = ANY('{${recIDs.join(',')}}');`).rows;
      var photos = result.filter(x => x.caption &amp;&amp; x.caption[0] == '#');
      return photos;
   };

   /**
    * @summary Retrieves photos from a specified application based on record IDs.
    * @description This function constructs a SQL query to select photos and their captions from a specified application, filtering by record IDs.
    * @param {string[]} recIDs - Array of record IDs to retrieve photos for.
    * @param {String} appID - The ID of the application from which to retrieve photos.
    * @param {String} photoDn - The data name of the photo field in the application.
    * @param {String} [orderDn=null] - The data name of the field to order the results by. If null, no ordering is applied.
    * @param {String} [qFlds=''] - Other columns to return, ie _record_id, _status
    * @returns {Array} - An array of photo objects, each containing photo_id and caption.
    */
   getPhotos(recIDs,appID,photoDn,orderDn=null,qFlds=''){
      const order = orderDn ? ` ORDER by ${orderDn}` : ''
      // const flds = qFlds ? qFlds + ', ' : ``
      const flds = qFlds ? qFlds : `*`
      const q = `SELECT ${flds}unnest(${photoDn}) as photo_id, unnest(${photoDn}_captions) as caption 
      FROM "${appID}" 
      WHERE _record_id = ANY('{${recIDs.join(',')}}') 
      ${order};`

      // WHERE _record_id IN ('${recIDs}')

      return QUERY(q).rows;
   }

   /**
    * 
    * @param {string[]} recIDs - Array of record IDs to retrieve.
    * @param {String} appID - The ID of the application from which to retrieve records.
    * @param {String} [orderDn=null] - The data name of the field to order the results by. If null, no ordering is applied.
    * @param {String} [qFlds=null] - Other columns to return, ie _record_id, _status
    * @returns {JSON[]} - An array of JSON objects representing the records.
    */
   getRecords(recIDs,appID,orderDn=null,qFlds=null){
      const order = orderDn ? ` ORDER by ${orderDn}` : '' 
      const flds = qFlds ? qFlds : `*`
      const q = `SELECT ${flds} 
      FROM "${appID}" 
      WHERE _record_id = ANY('{${recIDs.join(',')}}') 
      ${order};`

      // WHERE _record_id IN ('${recIDs}')
      // WHERE _record_id = ANY('{${recIDs.join(',')}}') 

      return QUERY(q).rows;
   }

   getRepRecs(recIDs,appID,repID,parentDns,childDns,orderDn){
      const order = orderDn ? ` ORDER by ${orderDn}` : ''
      const ptDns = parentDns ? `PT._record_id, ${parentDns}, ` : `PT._record_id, `
      const chDns = childDns ? `CH._record_id, ${childDns} ` : `CH._record_id `
      const q = `SELECT ${ptDns} ${chDns} 
      FROM "${appID}" 
      PT INNER JOIN "${appID}/${repID}" CH ON PT._record_id = CH._record_id 
      WHERE CH._record_id = ANY('{${recIDs.join(',')}}') 
      ${order};`

      return QUERY(q).rows;
   }

   makeTableHeaders(dns){
      var output = ''
      for (const dn of dns){
         output = output + `&lt;div>${LABEL(dn)}&lt;/div>`
      }
      return output
   }

   addCH(dns){
      var output = []
      for (const dn of dns){
         output.push(`CH.${dn}`)
      }
      return output.join(', ')
   }

   getFormFlds(appID){
      const url = `https://api.fulcrumapp.com/api/v2/forms/${appID}.json?schema=true`;
      const options = {
         method: 'GET',
         headers: {
            Accept: 'application/json',
            'X-ApiToken': mToken
         }
      };
      var response = GET(url,options)
      if(!response.form.elements){return response}
      
      const elements = response.form.elements
      var output = []
      for (const element of elements){
         if(element.elements){
            output = output.concat(element.elements)
         }
         else{
            output.push(element)
         }
      }
      return output
   }

   makeMfldsFromFormJSON(appFlds,flds){
      var mFlds = M.mkMflds([])
      appFlds = appFlds.filter((x)=> flds.includes(x.data_name))
      appFlds.forEach((x)=>mFlds.push(x))
      mFlds.forEach((x)=>x.span = 4)
      mFlds.forEach((x)=>x.opt ='')
      return mFlds
   }

   /**
    * @summary Retrieves the location information of a photo based on its photo_id.
    * @description buildPhotoSection > getPhotoGrid1x3 > getPhotoWraped > getPhotoLoc
    * 
    * @param {string} photo_id - The unique identifier of the photo.
    * @return {Object} - An object containing the latitude, longitude, direction, and created_at date of the photo. If any of these values are not available, they will be set to '---'.
    * @usedby getPhotoWraped - Wraps a photo object in HTML for display.
    * @usedby buildPhotoSection then getPhotoGrid1x3 then getPhotoWraped then getPhotoLoc
    */
   getPhotoLoc(photo_id = ''){
      const output = {};
      const locQuery = QUERY("SELECT record_id, latitude, longitude, direction, created_at FROM photos WHERE photo_id = '" + photo_id + "'");
      const row = locQuery.rows[0] || {};
    
      output.lat = row.latitude ? row.latitude.toFixed(4).toString() + '\xB0' : '---';
      output.lon = row.longitude ? row.longitude.toFixed(4).toString() + '\xB0' : '---';
      output.dir = row.direction ? row.direction.toFixed(2).toString() + '\xB0' : '---';
      // //add second query to use photo record_id to get date from record that photo is associated with
      output.date = '---'
      if(row &amp;&amp; row.exif){
         const exif = JSON.parse(row.exif)
         if(exif){
            output.date = exif.date_time_original.split('T')[0]
         }
      }
      
      return output;
   };

   /**
    * @summary Adds photo number/label field to JSON rows.
    * @description addItemNo > buildPhotoObjFromRows > buildPhotoSection > getPhotoGrid1x3 > getPhotoWraped > getPhotoLoc
    * @param {Array} rows - A array of JSON rows returned from https request.
    * @param {string} fldName - The data name of the photo field to add to rows and enumerate.
    * @return void - Mutates existing rows
    * 
    */
   addItemNo(rows, fldName = 'item_no') {
      for (let i = 0; i &lt; rows.length; i++) {
         rows[i][fldName] = i + 1;
      }
   }

   /**
    * @summary Builds a photo object from a https response.
    * @description buildPhotoObjFromRows > buildPhotoSection > getPhotoGrid1x3 > getPhotoWraped > getPhotoLoc
    * @param {Array} recs - A array of JSON rows returned from https request.
    * @param {string} dn - The data name of the photo field in the rows.
    * @param {string} [photoLbl='item_no'] - The field name in rows that contains the photo number/label.
    * @return {Object} - An object formatted as a fulcrum photo field object.
    * 
    */
   buildPhotoObjFromRows(recs, dn, photoLbl = 'item_no') {
      const output = [];
      for (let index = 0; index &lt; recs.length; index++) {
         const rec = recs[index];
         if (rec &amp;&amp; rec[dn]) {
         const photoNumLbl = index + 1;
         const capDn = dn + '_captions';
         for (let i = 0; i &lt; rec[dn].length; i++) {
            const obj = {};
            obj.photo_id = rec[dn][i];
            obj.caption = rec[capDn] ? rec[capDn][i] : '';
            obj[photoLbl] = rec.item_no ? rec.item_no.toString() : photoNumLbl.toString();
            output.push(obj);
         }
         }
      }
      return output;
   }

   /**
    * @summary Builds a photo section with a grid layout for displaying photos in a report.
    * @description buildPhotoSection > getPhotoGrid1x3 > getPhotoWraped > getPhotoLoc
    * @param {Array} photoOarr - An array of photo objects, each containing photo_id and caption properties.
    * @param {Object} secOpt - An optional object containing section options such as prefix, suffix, and other display settings.
    * @param {boolean} addXtra - A flag indicating whether to include additional fields in the photo display. 
    * @param {string} label - Fieldname to place above location and caption in photo margin 
    * @param {number} firstpg - The index of where to page break on the first page of photos. Default is 3.
    * @return {string} - The HTML string representing the photo section.
    */
   buildPhotoSection(photoOarr = [], secOpt = {}, addXtra = false, label = null,firstpg = 3) {
      var out = '';
      if (photoOarr &amp;&amp; photoOarr.length > 0) {
         secOpt.css = !secOpt.css ? 'spacer-bottom' : secOpt.css.includes('spacer-bottom') ? secOpt.css : secOpt.css + ' spacer-bottom'
         const divider = this.getSecHtml(secOpt);
         var htmlPhotos = this.getPhotoGrid1x3(photoOarr, secOpt, addXtra, label, firstpg);
         out = `\
            &lt;div class="clump">\
               ${divider}
               ${htmlPhotos}\
            &lt;/div>`;
      }
      return out;
   };

   /**
    * @Summary Build photo section from photos in repeatable
    * @description buildRepeatablePhotos > getPhotoGrid1x3 > getPhotoWraped > getPhotoLoc
    *
    * @param {string} [repDn=''] 
    * @param {string} [photoDn=''] 
    * @param {{}} [secOpt={}] 
    * @param {boolean} addXtra - A flag indicating whether to include additional fields in the photo display. 
    * @param {string} label - Fieldname to place above location and caption in photo margin 
    * @param {*} [callback=null] - function to add fields to photo caption
    * @returns {string} 
    */
   buildRepeatablePhotos(repDn = '', photoDn = '', secOpt = {}, addXtra = false, label = null, firstpg = 3, callback = null) {
      var out = '';
      if (REPEATABLEVALUES(VALUE(repDn), photoDn)) {
         out = '&lt;div class="clump">';
         for (var i = 0; i &lt; VALUE(repDn).length; i++) {
            var photoOarr = REPEATABLEVALUES(VALUE(repDn), photoDn)[i];
            if (photoOarr) {
               if (callback) {
                  callback(photoOarr, repDn, i);
               }
               secOpt.rep_data_name = repDn;
               secOpt.index = i;
               const divider = this.getSecHtml(secOpt);
               out = out + divider;
               var htmlOut = this.getPhotoGrid1x3(photoOarr, secOpt, addXtra, label, firstpg);
               out = out + htmlOut;
            }
         }
         out = out + '&lt;/div>';
      }
      return out;
   };

   /**
    * @description Removes # and ! from prefix of photo caption.
    * @param {string} val - Input caption string.
    * @returns {string} - The modified caption without the prefix.
    */
   remPhotoPre(val){
      if(!val) return '';
      var output = val;
      if(val.slice(0,1) == '#'){
         output = val.slice(1)
      }
      if(val.slice(1,2) == '!'){
         output = val.slice(2)
      }
      return output
   }

   /**
    * @description Generates a 1x3 photo grid layout for displaying photos in a report.
    * @param {Array} photoOarr - An array of photo objects, each containing photo_id and caption properties.
    * @param {Object} secOpt - An optional object containing section options such as prefix, suffix, and other display settings.
    * @param {boolean} addXtra - A flag indicating whether to include additional fields in the photo display.
    * @param {number} firstpg - The index of where to page break on the first page of photos. Default is 3. (ie 1=after the first 2 photos and 2=after the first 3 photos)
    * @return {string} - The HTML string representing the 1x3 photo grid layout.
    */
   getPhotoGrid1x3(photoOarr = [{}], secOpt = {}, addXtra = false, label=null, firstpg = 3) {
      if (photoOarr) {
         secOpt.css = !secOpt.css ? 'spacer-bottom' : secOpt.css.includes('spacer-bottom') ? secOpt.css : secOpt.css + ' spacer-bottom'
         var output = `&lt;div class="photo-grid1x3 grid-lo">`;
         for (let i = 0; i &lt; photoOarr.length; i++) {
            if ((i == firstpg)) {
               output += `&lt;div class="${secOpt.css} newPage" style="grid-column: span 2;">${this.getSecTxt(secOpt)} (continued)  &lt;/div>`;
            }
            if (i > firstpg &amp;&amp; (i - firstpg) % 3 == 0) {
               output += `&lt;div class="${secOpt.css}" style="grid-column: span 2;">${this.getSecTxt(secOpt)} (continued)  &lt;/div>`;
            }
            var photoObj = photoOarr[i];
            output += `${this.getPhotoWraped(photoObj, addXtra, label)}`;
         };
         output += `&lt;/div>`;
         return output;
      }
      if (!photoOarr) {
         return `&lt;div style="text-align:left">---&lt;/div>`;
      }
   };

   /**
    * @description Loop through additional addon photo properties and add to description.
    * 
    * Called from within getPhotoWraped to add additional custom fields besides caption to photo description if any are present.
    *
    * @param {{}} [photoObj={}] 
    * @returns {string} - html string of added photo text 
    */
   addCustomPhotoFlds(photoObj = {}) {
    const keys = Object.keys(photoObj).filter(key => key !== 'photo_id' &amp;&amp; key !== 'caption');
    return keys.map(key => `&lt;div>&lt;qh>${key}: &lt;/qh>${this.formatVal(photoObj[key])}&lt;/div>`).join('');
   }

   /**
    * @description Constructs html for one photo with caption and descriptive text.
    *
    * @param {{}} [photoObj={}] 
    * @param {boolean} [addXtra=false] 
    * @param {string} [photoLblFld='item_no'] 
    * @returns {string} 
    */
   getPhotoWraped(photoObj = {}, addXtra = false, photoLblFld = 'item_no') {
      const photoLoc = this.getPhotoLoc(photoObj.photo_id);
      let photoNoLbl = 'Item No';
      let photoNoVal = '';
    
      if (photoObj[photoLblFld]){
          photoNoLbl = M.dn2Title(photoLblFld.replace(/_/g, ' '));
          photoNoVal = photoObj[photoLblFld] || '';
      }
  
      const lblHtml = photoObj[photoLblFld] ? `&lt;div>${photoNoLbl}: ${photoNoVal}&lt;/div>` : '';
      const cap = this.formatVal(this.remPhotoPre(photoObj.caption)) || ''
      //Add to return string to include date
      //&lt;div>&lt;qh>Date: &lt;/qh>${photoLoc.date}&lt;/div>\
      return `\
         &lt;div class="photoWrapper">\
            &lt;img src="${PHOTOURL(photoObj.photo_id)}"/>\
         &lt;/div>\
         &lt;div class="captionWrapper">\
            ${lblHtml}\
            &lt;div>&lt;qh>Location: &lt;/qh>${photoLoc.lat}, ${photoLoc.lon}&lt;/div>\
            &lt;div>&lt;qh>Description: &lt;/qh>${cap}&lt;/div>\
            ${addXtra ? this.addCustomPhotoFlds(photoObj) : ''}\
         &lt;/div>`;
  }

   /**
    * @description Extracts Photo related properties from an Object (ie: row from Fulcrum Request) and creates a photo object array.
    * 
    * Use this before buildPhotoSection to create a photo array object to input.
    *
    * @param {string} [dn=''] - dn of field containing JSON array of data values (ie: summary records from datalink field)
    * @param {string} [dn=''] - dn in objDn containing photo_id values
    * @param {{}} [addOnFlds=['']] 
    * @returns {{}} 
    * 
    * @todo find if this is used anywhere. Change so input is rows instead of dn.
    */
  parsePhotoObj(inputDn = '', dn = '', addOnFlds = ['']) {
    const output = [];
    if (VALUE(inputDn)) {
      const capFld = dn + '_captions';
      const objArr = JSON.parse(VALUE(inputDn));
      for (const row of objArr) {
        if (row[dn] !== undefined) {
          const photoSet = row[dn];
          for (let idx = 0; idx &lt; photoSet.length; idx++) {
            const photoObj = {
              photo_id: row[dn][idx],
              caption: row[capFld] ? row[capFld][idx] : ''
            };
            if (addOnFlds) {
              for (const addonDn of addOnFlds) {
                if (row[addonDn] !== undefined) {
                  photoObj[addonDn] = row[addonDn];
                }
              }
            }
            output.push(photoObj);
          }
        }
      }
    }
    return output;
  }

   /**
    * @description Construct html of values from a obj. Input object and array of property names. Output values separated by divs.
    * 
    * Use this to construct divs for a table.
    *
    * @param {Object[]} rows
    * @param {{}} [dns=['']] 
    * @returns {string} 
    */
   parseObj2Div(rows, dns = [''],naVal='---') {
      var output = '';
      for(var i =0;i&lt;rows.length;i++){
         var row = rows[i]
         for(var j =0;j&lt;dns.length;j++){
            var dn = dns[j]
            if (row[dn] != undefined) {
               output = output + '&lt;div>' + this.formatVal(row[dn]) + '&lt;/div>';
            }
            if (row[dn] == undefined) {
               output = output + `&lt;div>${naVal}&lt;/div>`;
            }
         };
      };
      
      return output;
   }

   /**
    * @description Remove Photo Number from Caption and place in separate field while also stripping photo number from Caption.
    * Photo number must be the first n characters of caption followed by a delimmeter that can be specified in the paramaters
    *
    * @param {{photo_id:string,caption:string}} photoOarr - photo Object array
    * @param {string} delimmiter - string separating photo number from remainder of caption
    * @param {string} [numFld='photo_number'] - Label for add on Photo Number Label field, must be in "data name" format. ie(photo_number)
    * @example
    * &lt;%
    *    var photoFld_dn = 'photos'
    *    var sitePhotos = VALUE(photoFld_dn)
    *    caption2Number(sitePhotos,'.') //first characters of caption must be an identifier followed by '.'
    * >%
    * &lt;%-
    *    M.buildPhotoSection(sitePhotos,{"prefix":"Appendix","center":$appendix},false,'photo_number')
    * %>
    */
   caption2Number(photoOarr,delimmiter,numFld='photo_number'){
      function stripPhotoNumber(cap,delimmiter){
        if(cap){
          var del = cap.indexOf(delimmiter)
          if(del > -1){
            return cap.slice(0,del)
          } else { return cap }
        } else {return ''}
      }
    
      for (const photo of photoOarr){
        var newCap = stripPhotoNumber(photo.caption,delimmiter)
        var capStart = newCap.length + delimmiter.length
        photo[numFld] = M.padZero(newCap,3)
        if(photo.caption &amp;&amp; capStart &lt; 5){
          var newDes = photo.caption.slice(capStart).trim()
          photo.caption = newDes
        }
      }
    }


    /**
     * @description Description placeholder
     *
     * @param {string} formID 
     * @param {Array&lt;{record_id:string}>} vals - array of record_id
     * @param {Array} flds - array of data_names
     * @param {string} orderDn - data_name of field to sort by
     * @returns {*} 
     */
   getRLrecords(formID,vals,flds,orderDn){
      function getIDs(vals) {
         if (!vals || vals.length === 0) return [];
         return !Array.isArray(vals) ? vals
                  : Object.prototype.toString.call(vals[0]) === '[object Object]' ? vals.map(x => x.record_id)
                     : vals
      }
      
      const order = orderDn ? ` ORDER BY ${orderDn}` : ''
      const qFlds = flds ? '_record_id, ' + flds.join(', ') : '*'
      const ids = getIDs(vals).join('\',\'')

      const q = `SELECT ${qFlds} 
      FROM "${formID}" 
      WHERE _record_id IN ('${ids}')
      ${order};`

      const result = ids.length > 0 ? QUERY(q, {format: 'json'}) : {"rows":[]}
      return result.rows
   }

   /**
    * @description Description placeholder
    *
    * @returns {string} 
    */
   addSignatureTrim(){
      return `&lt;script>
         window.onload = function(){
            const originalImage = document.getElementById('originalSignature');
            try{
            if (originalImage.complete) {
               trimAndDisplay();
            } else {
               originalImage.onload = trimAndDisplay;
            }
            } catch(err) {
            document.getElementById("error").innerHTML = err.message;
            }
         }
            
         function trimAndDisplay() {
            // const sigUrl = SIGNATUREURL($inspector_signature &amp;&amp; $inspector_signature.signature_id)
            // const image = new Image();
            // image.src = sigUrl;
      
            const originalImage = document.getElementById('originalSignature');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
      
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            ctx.drawImage(originalImage, 0, 0);
      
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
      
            let minX = canvas.width;
            let minY = canvas.height;
            let maxX = 0;
            let maxY = 0;
      
            for (let y = 0; y &lt; canvas.height; y++) {
            for (let x = 0; x &lt; canvas.width; x++) {
               const index = (y * canvas.width + x) * 4;
               const alpha = data[index + 3];
      
               if (alpha > 0) {
                  minX = Math.min(minX, x);
                  minY = Math.min(minY, y);
                  maxX = Math.max(maxX, x);
                  maxY = Math.max(maxY, y);
               }
            }
            }
      
            const width = maxX - minX + 1;
            const height = maxY - minY + 1;
      
            if (width > 0 &amp;&amp; height > 0) {
            const trimmedCanvas = document.createElement('canvas');
            trimmedCanvas.width = width;
            trimmedCanvas.height = height;
            const trimmedCtx = trimmedCanvas.getContext('2d');
            const trimmedImageData = ctx.getImageData(minX, minY, width, height);
            trimmedCtx.putImageData(trimmedImageData, 0, 0);
      
            const trimmedImage = document.getElementById('trimmedSignature');
            trimmedImage.src = trimmedCanvas.toDataURL('image/png');
            trimmedImage.style.display = 'block';
            } else {
            console.log("No signature detected (or image fully transparent).");
            // Optionally display the original image if no trimming occurs:
            //originalImage.style.display = 'block';
            }
            originalImage.style.display = 'none'; // Hide the original image after processing
         };
      &lt;/script>`
   };

   /**
    * @description Description placeholder
    *
    * @returns {string} 
    */
   addSignatureTrim2(){
      return `&lt;script>
         var currentImg = 0
         window.onload = function(){
            for(let i = 0;i&lt;3;i++){
               currentImg = i
               var originalImage = document.getElementById('originalSignature'+currentImg.toString());
               var trimmedImage = document.getElementById('trimmedSignature' + currentImg.toString());
               try{
               if (originalImage.complete) {
                  trimAndDisplay();
               } 
               else {
                  trimmedImage.onload = trimAndDisplay;
               }
               } catch(err) {
               // document.getElementById("error").innerHTML = err.message;
               document.getElementById("sig" + currentImg.toString()).innerHTML = err.message;
               }
            }
         }
            
         function trimAndDisplay() {
            const originalImage = document.getElementById('originalSignature' + currentImg.toString());
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            ctx.drawImage(originalImage, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            let minX = canvas.width;
            let minY = canvas.height;
            let maxX = 0;
            let maxY = 0;

            //Test message
            document.getElementById("sig" + currentImg.toString()).innerHTML = originalImage.width
            

            for (let y = 0; y &lt; canvas.height; y++) {
               for (let x = 0; x &lt; canvas.width; x++) {
               const index = (y * canvas.width + x) * 4;
               const alpha = data[index + 3];

               if (alpha > 0) {
                  minX = Math.min(minX, x);
                  minY = Math.min(minY, y);
                  maxX = Math.max(maxX, x);
                  maxY = Math.max(maxY, y);
               }
               }
            }

            const width = maxX - minX + 1;
            const height = maxY - minY + 1;

            if (width > 0 &amp;&amp; height > 0) {
               const trimmedCanvas = document.createElement('canvas');
               trimmedCanvas.width = width;
               trimmedCanvas.height = height;
               const trimmedCtx = trimmedCanvas.getContext('2d');
               const trimmedImageData = ctx.getImageData(minX, minY, width, height);
               trimmedCtx.putImageData(trimmedImageData, 0, 0);

               const trimmedImage = document.getElementById('trimmedSignature' + currentImg.toString());
               
               trimmedImage.src = trimmedCanvas.toDataURL('image/png');
               trimmedImage.style.display = 'block';
            
            } else {
            console.log("No signature detected (or image fully transparent).");
            // Optionally display the original image if no trimming occurs:
            //originalImage.style.display = 'block';
            }
            originalImage.style.display = 'none'; // Hide the original image after processing
         };
      &lt;/script>`
   }
}
//#endregion

export { Helpers,FulcrumHelpers,MLoadRecs,FieldHelpers,MfldColl,Mfld,SecOpt,ReportHelpers}</code></pre>
		</section>
			</div>
		</div>
	</div>
	<footer>
				<div class="copyright"> </div>
			<div class="generated-by">Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on 15th Sep 2025 using the <a href="https://github.com/steveush/foodoc">FooDoc template</a>.</div>
	</footer>
	<script src="js/jquery.min.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<script src="js/clipboard.min.js"></script>
	<script src="js/prism.min.js"></script>
	<script src="js/template.min.js"></script>
		<!-- start:lunr-search-modal.hbs -->
		<div class="modal fade" id="lunr-search-modal">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
						<h4 class="modal-title">Search results</h4>
					</div>
					<div class="modal-body" id="lunr-search-body">
					</div>
					<div class="modal-footer" id="lunr-search-footer">
						<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
					</div>
				</div><!-- /.modal-content -->
			</div><!-- /.modal-dialog -->
		</div>
		<!-- end:lunr-search-modal.hbs -->		<script src="js/lunr.min.js"></script>
	
</body>
</html>
<!-- end:source.tmpl.hbs -->